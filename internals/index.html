<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Internals</title>
  <meta name="description" content="JerryScript is a very lightweight JavaScript engine with capability to run on microcontrollers with less then 8KB of RAM.
">

  <link rel="stylesheet" href="/jerryscript/css/main.css">
  <link rel="canonical" href="http://samsung.github.io/jerryscript/internals/">
  <link rel="alternate" type="application/rss+xml" title="JerryScript Engine" href="http://samsung.github.io/jerryscript/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/jerryscript/">JerryScript Engine</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
        
          
          <a class="page-link" href="/jerryscript/how-to/">How To</a>
          
        
          
          <a class="page-link" href="/jerryscript/API/">API</a>
          
        
          
          <a class="page-link" href="/jerryscript/internals/">Internals</a>
          
        
          
          <a class="page-link" href="/jerryscript/dev-guide/">Development</a>
          
        
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Internals</h1>
  </header>

  <article class="post-content">
    <p><img src="/jerryscript/img/engines_high_level_design.jpg" alt="High-Level Design" /></p>

<p>On the diagram above is shown interaction of major components of software system: Parser and Runtime. Parser performs translation of input ECMAScript application into byte-code with specified format (refer to <a href="/internals/#byte-code">Bytecode</a> and <a href="/internals/#parser">Parser</a> page for details). Prepared bytecode is executed by Runtime engine that performs interpretation (refer to <a href="/internals/#virtual-machine">Virtual Machine</a> and <a href="/internals/#ECMA">ECMA</a> pages for details).</p>

<h1 id="parser">Parser</h1>

<p>The parser is implemented as recursive descent parser. The parser does not build any type of Abstract Syntax Tree. It converts source JavaScript code directly into byte-code.</p>

<p>The parser consists of three major parts:<br />
- lexer<br />
- parser<br />
- opcodes dumper<br />
- syntax errors checker<br />
- serializer</p>

<p>These four (except the parser itself) components are initialized during <code>parser_init</code> call (jerry-core/parser/js/parser.cpp).</p>

<p>This initializer requires two following subsystems to be initialized: memory allocator and serializer. The need for allocator is clear. The serializer resets internal bytecode_data structure(jerry-core/parser/js/bytecode-data.h). Currently bytecode_data is singleton. During parsing it is filled by data which is needed for further execution:</p>

<ul>
  <li>Byte-code - array of opcodes (<code>bytecode_data.opcodes</code>).</li>
  <li>Literals - array of literals (<code>bytecode_data.literals</code>).</li>
  <li>Strings buffer (<code>bytecode_data.strings_buffer</code>) - literals of type <code>LIT_STR</code> contain pointers to strings, which are located in this buffer.</li>
</ul>

<p>The following is brief review of the mentioned components. See more concise description in the following chapters.</p>

<ul>
  <li>Lexer<br />
The lexer splits input file (given as the first parameter of the parser_init call) into sequence of tokens. These tokens are then matched on demand.</li>
  <li>Opcodes dumper<br />
This component does necessary checks and preparations, and dumps opcodes using serializer.</li>
  <li>Serializer<br />
The serializer puts opcodes, prepared by the dumper, to a continuous array that represents current scope’s code. Also it provides API for accessing byte-code.</li>
  <li>Syntax error checker<br />
This is bunch of simple die-on-error checks.</li>
</ul>

<p>After initialization <code>parser_parse_program</code> (<code>./jerry-core/js/parser.cpp</code>) should be called. This function performs the following steps (so-called parsing steps) for all scopes (global code and functions):</p>

<ol>
  <li>Initialize a scope.</li>
  <li>Do pre-parser stage.</li>
  <li>Parse scope code.</li>
</ol>

<p>After every scope is processed, parser merges all scopes into single byte-code array.</p>

<p>Two new entities were introduced - scopes and pre-parser.</p>

<ul>
  <li>There are two types of scopes in the parser: global scope and function declaration scope. Notice that function expressions do not create a new scope in terms of the parser. A reason why is described below.<br />
Parsing process starts on global scope. If a function declaration occurs string the process, new scope is created, this new scope is pushed to a stack of current scopes; then steps 1-3 of parsing are performed. Note, that only global scope parsing shall merge all scopes into a byte-code. All scopes are stored in a tree to represent a hierarchy of them.</li>
  <li>Pre-parser. This step performs hoisting of variable declarations.  First, it dumps <code>reg_var_decl</code> opcodes. Then it goes through the script and looks for variable declaration lists. For every found variable in the scope (not in a sub-scope or function expression) it dumps var_decl opcode. After this step byte-code in the scope starts with optional <code>'use strict'</code> marker, then <code>reg_var_decl</code> and several (optional) <code>var_decls</code>.</li>
</ul>

<p>Due to some limitations of the parser, some parsing functions take <code>this_arg</code> and/or <code>prop</code> as parameters. They are further used to dump <code>prop_setter</code> opcode.</p>

<p>During parsing all necessary data is stored in either stacks or scope trees.</p>

<p>After parsing of whole program, the parser merges all scopes into a single byte-code, hoisting function declarations in process. This task, so-called post-parser, is performed by <code>scopes_tree_raw_data</code> (jerry-core/js/scopes-tree.c) function. For further information about post-parser, check opcodes dumper section.</p>

<p>Currently the parser does not support labeled statements and for-in loops.  </p>

<h3 id="lexer">Lexer</h3>

<p>The lexer splits input string on set of tokens. The token structure (jerry-core/parser/js/lexer.h) consists of three elements: token type, location of the token and optional data:<br />
<code>
typedef struct
{
  locus loc;
  token_type type;
  literal_index_t uid;
}
token;
</code></p>

<p>Location of token (<code>locus</code>). It is just an index of first token’s character at a string that represents the program.</p>

<p>Token types are are listed in lexer.h header file (<code>token_type</code> enum). Depending on token type, token specific data (<code>uid</code> field) has the different meaning.</p>

<table>
  <thead>
    <tr>
      <th>Token type</th>
      <th><code>uid</code> meaning</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TOK_KEYWORD</td>
      <td>Keyword id, like KW_DO, KW_CONST, etc. (see <code>keyword</code> enum in lexer.h).</td>
    </tr>
    <tr>
      <td>TOK_NAME, TOK_STRING, TOK_NUMBER</td>
      <td>Literal index in the stack of literals.</td>
    </tr>
    <tr>
      <td>TOK_BOOL</td>
      <td>0 - <code>false</code> <br /> 1 - <code>true</code></td>
    </tr>
    <tr>
      <td>TOK_SMALL_INT</td>
      <td>Value of small integer (0-255).</td>
    </tr>
    <tr>
      <td>Other (punctuators)</td>
      <td>Not used.</td>
    </tr>
  </tbody>
</table>

<p>Token matching algorithm is straightforward - look at the first character of new token, recognize the type, and then just match the rest. Comments and space characters (except new line) are ignored, so they produce no token. The algorithm uses two pointers: buffer and token_start. The first one points to the next character of the input, the other one points to the first character of token, being matched, so-called current token.</p>

<p>The lexer remembers two tokens during scan: current and previously seen. It also allows buffering one token to be rescanned (<code>lexer_save_token</code>) and setting scan position to any location in the file (<code>lexer_seek</code>).</p>

<p>The parser uses lexer two scan file two times - during pre-parsing and parsing stages.</p>

<p>Currently the lexer does not support any encoding except ASCII. Also the lexer does not support regular expressions.</p>

<h3 id="opcodes-dumper">Opcodes dumper</h3>

<p>It is a quite high level wrapper for the serializer. It was introduced to split functionality of parsing and dumping opcodes. To understand how opcodes dumper works, one should be acquainted with the byte-code layout (see the corresponding description).</p>

<p>The main data structure of the dumper is an operand (jerry-core/parser/js/opcodes-dumper.h). Operand can represent either variable (i.e. literal) or temporary register (tmp). The most annoying thing of the dumper is a difference between these types.</p>

<p>Byte-code is divided into blocks of fixed size (<code>BLOCK_SIZE</code> in jerry-core/parser/js/bytecode-data.h) and each block has independent encoding of variable names, which are represented by 8 bit numbers - uids.<br />
Operands are encoded as uids in each opcode (see the <code>opcode_t</code> structure).<br />
As byte-code decomposition into blocks is not possible until parsing is finished, uids can’t be calculated on the fly. Therefore literal operands are encoded by literal indexes (<code>literal_index_t</code> - index in the global literals array) during parsing. In the post-parser stage these indexes are converted to block specific uids.</p>

<p>During parsing scopes tree structure is constructed (see <code>scopes_tree_int</code> in the jerry-core/parser/js/scopes-tree.h). Each tree node comprises of its byte-code and list of child scopes. While final byte-code is the plain array of <code>opcode_t</code> structures, byte-code in tree nodes is represented by the list of <code>op_meta</code> structures. Op_meta structure wraps <code>opcode_t</code> with an array of 3 values (result, operand_1 and operand_2), which holds literal indexes, so that literal operands could be encoded.</p>

<p>In each dump_* function (jerry-core/parser/js/opcodes-dumper.h) the dumper checks for the operand type and dumps appropriate op_meta to the scopes tree using serializer. The dumper also keeps opcode counters of rewritable opcodes inside a bunch of stacks. It dumps an op_meta and pushed an opcodes counter of the op_meta to a stack in functions with a name like dump_*_for_rewrite, then pops an opcode counter from the stack, retrieves op_meta by the dematerializer and rewrites necessary fields of opcodes in functions with names like rewrite_*.</p>

<p>The post-parser merges scopes into a single byte-code. For each scope it first dumps a header of the scope, which consists of optional func_decl with function_end opcode pair, optional ‘use strict’ marker, <code>reg_var_decl</code> and optional <code>var_decls</code>. Then it recursively dumps sub-scopes. Finally, it dumps the remainder of opcodes. The byte-code is split into blocks with fixed size; each block has its own counter of literals. While dumping opcodes the post-parser replaces LITERAL_TO_REWRITE markers with this counter’s value.</p>

<h3 id="serializer">Serializer</h3>

<p>Serializer dumps literals collected by the lexer to bytecode_data, is used by the dumper to dump or rewrite op_metas to a current scope. There is no much to say about this component.</p>

<h3 id="syntax-errors-checker">Syntax Errors Checker</h3>

<p>This component is just checks for syntax errors defined in the specification. It uses stacks to store necessary data, for example arguments names.</p>

<h1 id="byte-code">Byte-code</h1>
<p>Every instruction of bytecode consists of opcode and up to three operands. Operand (idx) can be either a “register” or a string<br />
literal, specifying identifier to evaluate (i.e. <code>var //Storage idx</code>). General structure of instruction is shown on the picture.  <br />
<img src="/img/bytecode_view.jpg" alt="Structure of instruction" /></p>

<p>Special kinds of instructions are described below.</p>

<h2 id="arithmeticbitwise-logiclogiccomparisonshift">Arithmetic/bitwise-logic/logic/comparison/shift</h2>
<p>Arithmetic instruction can have the following structure:  </p>

<p><img src="/img/bytecode_arithmetic.jpg" alt="Arithmetic instructions" /></p>

<p>where dst/left/right/value identify an operand.</p>

<h2 id="control-jumps">Control (jumps)</h2>
<p>Control instructions utilize two bytes to encode jump location. Destination offset is contained inside <code>offset_high</code> and <code>offset_low</code> fields.  </p>

<p><img src="/img/bytecode_control.jpg" alt="Control instructions" /></p>

<p>Condition jump checks <code>cond value</code> field, which identifies an operand, and performs a jump if the operand has <code>true</code> value.</p>

<h2 id="assignment">Assignment</h2>

<p>Assignment instructions perform assignment of immediate value (contained inside instruction) to the operand, which is marked as <code>idx</code> on the picture.</p>

<p><img src="/img/bytecode_assignment.jpg" alt="Assignment instruction" /></p>

<p>Type of the immediate value is encoded in the <code>type</code> field of instruction. The following values are supported:<br />
- “simple value” (see ECMA types encoding)<br />
- small integer/negative small integer<br />
- number literal/negative number literal<br />
- sring value, initialized by string literal (“literal idx”)<br />
- “Srorage idx”</p>

<h2 id="exit">Exit</h2>

<p>Exit instruction serves to stop the execution and exit with a specified status.</p>

<p><img src="/img/bytecode_exit.jpg" alt="Exit instruction" /></p>

<p>Exit instruction is employed in following cases:<br />
- at script end (exit with “succesful” stats);<br />
- in script assertion fail handling code (exit with “fail” status)</p>

<h2 id="native-call-intrinsic-call">Native call (intrinsic call)</h2>

<p>Native call instruction is used to call intrinsics. Arguments are not encoded directly inside this instruction, instead they follow it as special “meta” instructions (see the according section). Id of desired intrinsic is encoded in the <code>intrinsic id</code> field.</p>

<p><img src="/img/bytecode_native.jpg" alt="Native call instruction" /></p>

<h2 id="function-callconstructor-call">Function call/Constructor call</h2>

<p>Function/constructor call are utilized to perform calls to functions and constructors. Destination operand is encoded in <code>dst</code> field. Operand <code>name_idx</code> specifies the name of the function to call. Arguments are encoded the same way as in native call instruction.</p>

<p><img src="/img/bytecode_fcall.jpg" alt="Function/constructor instruction" /></p>

<h2 id="function-declaration">Function declaration</h2>

<p>Function declarations are represented by special kind of instructions. Function name and number of arguments are located in <code>name_idx</code> and <code>arg_list</code> fields respectively.</p>

<p><img src="/img/bytecode_fdecl.jpg" alt="Function declaration instruction" /></p>

<h2 id="function-expression">Function expression</h2>

<p>Very similar to function declaration. But additionally contains destination (<code>dst</code>) field and <code>name</code> operand is optional, because anonymous functions are possible.</p>

<p><img src="/img/bytecode_fexpr.jpg" alt="Function expression instruction" /></p>

<h2 id="return-from-functioneval">Return from function/eval</h2>

<p>Return instructions perfrom unconditional return from function/eval code. Return value can be specified (<code>idx</code> field).</p>

<p><img src="/img/bytecode_ret.jpg" alt="Return instruction" /></p>

<h2 id="meta-special-marker-opcode">“Meta” (special marker opcode)</h2>

<p><img src="/img/bytecode_meta.jpg" alt="Meta instruction" /></p>

<p>Meta instructions are usually utilized as continuations of other instructions. Depending on <code>type</code> field, meta instruction can have the following meaning:</p>

<ul>
  <li>‘this’ argument (for calls in a.f() form, a = this), put right after call opcode</li>
  <li><code>varg</code> (encodes an argument for calls and array declarations (<code>arg1</code> - storage idx) / parameters name for function decl/expr (<code>arg1</code> - literal idx, i.e. string))</li>
  <li>carg_prop_data / varg_prop_getter / varg_prop_setter - name (literal idx) and value/getter/setter (storage idx) of a property (see also: object declaration)</li>
  <li>end_with / function_end / end_of_try_catch_finally - end offset of ‘with’ block/function/try_catch_finally sequence</li>
  <li>catch / finally - start of catch/finally block and offset to the end of the block</li>
  <li>strict code - placed at the start of a scope’s code if the source code contains ‘use strict’ at the beginning</li>
</ul>

<h2 id="delete">Delete</h2>

<p>JavaScript delete operator is modeled with delete instruction in the bytecode. There are two types of delete instruction, applied either to element of lexical environment or to object’s property.</p>

<p><img src="/img/bytecode_delete.jpg" alt="Delete instructions" /></p>

<h2 id="this-binding-evaluate-this">This binding (evaluate “this”)</h2>
<p>This binding instruction writes value of “this” to the <code>dst</code> operand.</p>

<p><img src="/img/bytecode_binding.jpg" alt="This instruction" /></p>

<h2 id="typeof-typeof-operation">typeof (typeof operation)</h2>

<p>Typeof instruction executes JavaScript operator with the same name. Result is written to the <code>dst</code> operand.</p>

<p><img src="/img/bytecode_typeof.jpg" alt="Typeof instruction" /></p>

<h2 id="with-block">with block</h2>

<p>To specify bounds of “with” block, a pair of instructions is used. “With” instruction specifies its start. Followed by a number of arbitrary instructions, the block ends with <code>end_with</code> meta instruction.</p>

<p><img src="/img/bytecode_with.jpg" alt="With block instruction" /></p>

<h2 id="try-block">try block</h2>

<p>Try block consists of try instruction, followed by a number of arbitrary instructions, meta instruction <code>catch</code> or <code>finally</code> or both of them, separating catch and finally blocks respectively and meta instruction <code>end_try_catch_finally</code>, which finishes the whole construction.</p>

<p><img src="/img/bytecode_try.jpg" alt="Try block instruction" /></p>

<h2 id="object-declaration">Object declaration</h2>

<p>Obect declaration instruction represents object literal in JavaScript specification. It consists of <code>op_obj_decl</code> instruction, followed by a list of <code>prop_data</code>, <code>prop_getter</code> and <code>prop_setter</code> meta instructions. A series of instructions which evaluate property values can precede meta instructions. Number of meta instructions, e.g. number of properties, is specified in the <code>prop_num</code> field.</p>

<p><img src="/img/bytecode_obj.jpg" alt="Object declaration instruction" /></p>

<h2 id="arguments-and-array-declarartion">Arguments and array declarartion</h2>

<p>The strategy descibed in previous section is also used for encoding of arguments in function/constructor calls and elements in array declarations.<br />
See the according pictures.</p>

<p><img src="/img/bytecode_with.jpg" alt="Arguments/Array elements representation" /></p>

<h1 id="virtual-machine">Virtual machine</h1>

<p>Virtual machine executes bytecode by interpreting instructions one by one. Bytecode is a continuous array of instructions, divided into blocks of fixed size. Main loop of interpreter calls <code>opfunc_*</code> for every instruction. This function returns completion value and position of the next instruction.</p>

<p><img src="/img/bytecode_storage.jpg" alt="Bytecode storage" /></p>

<p>Instruction can have up to three operands which are represented by <code>idx</code> values. Meaning of <code>idx</code> value depends on opcode and can be the following:</p>

<ul>
  <li>id of a temporary variable (register)</li>
  <li>id of literal (quiried form serializer, specific to every block of bytecode)</li>
  <li>type of assigned value, id of number/string literal or simple value in <code>op_assignment</code></li>
  <li>type of meta and corresponding arguments in <code>op_meta</code></li>
  <li>idx pair may represent opcode position</li>
</ul>

<p>During execution every function of the source code has associated<br />
interpreter context, which consists of the following items:</p>

<ul>
  <li>current position (byte-code instruction to execute)</li>
  <li>‘this’ binding (ecma-value)</li>
  <li>lexical environment</li>
  <li><code>is_strict</code> flag (is current execution code strict)</li>
  <li><code>is_eval_code_lag</code> (is current execution mode eval)</li>
  <li><code>min_reg_num</code>, <code>max_reg_num</code> - range of <code>idx</code>’s used for “registers”</li>
  <li>stack frame (array of “register” values)</li>
</ul>

<p>Main routines of the virtual machine are:</p>

<ul>
  <li><code>run_int</code> - starts execution of Global code (main program).</li>
  <li><code>run_int_from_pos</code> - executes specified code scope<br />
(global/function/eval), expects the following arguments: starting<br />
position, ‘this’ binding, lexical environment.</li>
  <li><code>run_int_loop</code> - interpretation loop.</li>
</ul>

<h1 id="ecma">ECMA</h1>

<p>ECMA component of the engine is responsible for following notions:<br />
- Data representation<br />
- Runtime representation<br />
- GC</p>

<h2 id="data-representation">Data representation</h2>

<p>The major structure for data representation is <code>ECMA_value</code>. Lower two bits of this structure encode value tag, which determines the type of the value:</p>

<ul>
  <li>simple</li>
  <li>number</li>
  <li>string</li>
  <li>object</li>
</ul>

<p><img src="/img/ecma_value.jpg" alt="ECMA value representation" /></p>

<p>The immediate value is placed in higher bits. “Simple value” is an enumeration, which consists of the following elements:<br />
- undefined<br />
- null<br />
- true<br />
- false<br />
- empty<br />
- array_redirect (implementation defined, currently unused, for array storage optimization)</p>

<p>For other value types higher bits of <code>ECMA_value</code> structure contain compressed pointer to the real value.</p>

<h3 id="compressed-pointers">Compressed pointers</h3>

<p>Compressed pointers were introduced to save heap space. They are possible because heap size is currently limited by 256 KB, which requires 18 bits to cover it. ECMA values in heap are aligned by 8 bytes and this allows to save three more bits, so that compressed pointer consumes 15 bits only.</p>

<p><img src="/img/ecma_compressed.jpg" alt="Heap and ECMA elements" /></p>

<p>ECMA data elements are allocated in pools (pools are allocated on heap)<br />
Chunk size of the pool is 8 bytes (reduces fragmentation).</p>

<h3 id="number">Number</h3>

<p>There are two possible representation of numbers:<br />
- 4-byte (float, compact profile - no memory consumption, but hardware limitations)<br />
- 8-byte (double, full profile)</p>

<p>Several references to single allocated number are not supported. Each reference holds its own copy of a number.</p>

<h3 id="string">String</h3>

<p>String values are encoded by 8-byte structure, which contains the following fields:</p>

<ul>
  <li>references counter - each stack (and non_stack) reference is counted (upon overflow, string is duplicated)</li>
  <li>is_stack_allocated - some temporary strings are stack_allocated to reduce loading of memory (perf)</li>
  <li>container - type of actual string storage/encoding</li>
  <li>hash - hash, calculated from two last characters (for faster comparison (perf))</li>
  <li>literal identifier - actual string is in the literal storage</li>
  <li>magic_string_id - string is equal to one of engine’s magic strings</li>
  <li>uint32 - string is represented with unsigned integers (useful for array indexing)</li>
  <li>number_cp (compressed pointer to number) - string is represented with floating point number</li>
  <li>collection_cp - string is stored in one or several pool’s chunks (see also: chars collection, collection header, collection chunk)</li>
  <li>concatenation_1_cp, concatenation_2_cp - pointers to two strings (parts of concatenation)</li>
</ul>

<h3 id="object--lexical-environment">Object / Lexical environment</h3>

<p>Object and lexical environment structures, 8 bytes each, have common (GC) header:<br />
- Stack refs counter<br />
- Next object/lexical environment in list of objects/lexical environments<br />
- GC’s visited flag<br />
- is_lexenv flag</p>

<p>Remaining fields of these structures are different and are shown on the picture.</p>

<p><img src="/img/ecma_object.jpg" alt="Object/Lexicat environment structures" /></p>

<h3 id="property-of-an-object--description-of-a-lexical-environment-variable">Property of an object / description of a lexical environment variable</h3>

<p>While objects comprise of properties, lexical environments consist of variables. Both of these units are tied up into lists. Unit types could be different:<br />
- named data (property or variable)<br />
- named accessor (property)<br />
- internal (implementation defined)</p>

<p>All these units occupy 8 bytes and have common header:<br />
- type - 2 bit<br />
- next property/variable in the object/lexical environment (compressed pointer)</p>

<p>The remaining parts are differnt:<br />
<img src="/img/ecma_object_property.jpg" alt="Object property/lexcial environment variable" /></p>

<h3 id="collections">Collections</h3>

<p>ECMA runtime utilizes collections for intermediate calculations. Collection consists of a header and a number of linked chunks, which hold collection values.</p>

<p>Header occupies 8 bytes and consists of:</p>

<ul>
  <li>compressed pointer to the next chunk</li>
  <li>number of elements</li>
  <li>rest space, aligned down to byte, is for first chunk of data in collection</li>
</ul>

<p>Chunk’s layout is following:</p>

<ul>
  <li>compressed pointer to next chunk</li>
  <li>rest space, aligned down to byte, is for data stored in corresponding part of the collection</li>
</ul>

<h3 id="internal-properties">Internal properties:</h3>

<ul>
  <li>[[Class]] - class of the object (ECMA-defined)</li>
  <li>[[Prototipe]] - is stored in object description</li>
  <li>[[Extensible]] - is stored in object description</li>
  <li>[[CScope]] - lexical environment (function’s variable space)</li>
  <li>[[ParametersMap]] - arguments object -0 code of the function</li>
  <li>[[Code]] - where to find bytecode of the function</li>
  <li>native code - where to find code of native unction</li>
  <li>native handle - some uintptr_t assosiated with the objec</li>
  <li>[[FormalParameters]] - collection of pointers to ecma_string_t (the listof formal parameters of the function)</li>
  <li>[[PrimitiveValue]] for String - for String object</li>
  <li>[[PrimitiveValue]] for Number - for Number object</li>
  <li>[[PrimitiveValue]] for Boolean - for Boolean object</li>
  <li>built-in related:
    <ul>
      <li>built-in id - id of built-in object</li>
      <li>built-in routine id - id of built-in routine</li>
      <li>“non-instantiated” mask - what built-in properties where notinstantiated yet (lazy instantiation)</li>
      <li>extention object identifier</li>
    </ul>
  </li>
</ul>

<h3 id="lcache">LCache</h3>

<p>LCache is a cache for property variable search requests.</p>

<p><img src="/img/ecma_lcache.jpg" alt="LCache" /></p>

<p>Entry of LCache has the following layout:<br />
- object pointer<br />
- property name (pointer to string)<br />
- property pointer</p>

<p>Caches’s row is defined by string’s hash. When a property access occurs, all row’s entries are searched by comparing object pointer and property name to according entry’s fields, full comparison is used for property name.</p>

<p>If corresponding entry was found, its property pointer is returned (may be NULL - in case when there is no property with specified name in given object).<br />
Otherwise, object’s property set is iterated fully and corresponding record is registered in LCache (with property pointer if it was found or NULL  otherwise).</p>

<h2 id="runtime">Runtime</h2>

<p>ECMA-defined runtime operations are implemented mostly with routine having the following signature:</p>

<p><code>ecma_completion_value_t ecma_op_* ([ecma_value_t argumants])</code>  <br />
or  <br />
<code>ecma_property_t * ecma_op_[find/get]*_property (objs, name string, ...)</code>  </p>

<p>However, there could be some combinations.</p>

<h3 id="completion-value">Completion value</h3>

<p>Many algorithms/routines described in ECMA return a value of “completion” type, that is triplet of the following form:</p>

<p><img src="/img/ecma_completion.jpg" alt="ECMA completion" /></p>

<p>Jerry introduces two additional completion types:<br />
- exit - produced by <code>exitval</code> opcode, indicates request to finish execution<br />
- meta - produced by meta instruction, used to catch meta opcodes in interpreter loop without explicit comparison on every iteration (for example: meta ‘end_with’)</p>

<h3 id="value-management-and-ownership">Value management and ownership</h3>

<p>Every value stored by engine is associated with virtual “ownership” (that is responsibility to manage the value and free it when is is not needed, or pass ownership of the value to somewhere)</p>

<table>
  <thead>
    <tr>
      <th>Value type</th>
      <th>“Alloc” op</th>
      <th>“Free” op</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Number</td>
      <td>ecma_alloc_number</td>
      <td>ecma_dealloc_number</td>
    </tr>
    <tr>
      <td>String</td>
      <td>ecma_copy_or_ref_ecma_string</td>
      <td>ecma_deref_ecma_string</td>
    </tr>
    <tr>
      <td>Object</td>
      <td>ecma_ref_object (for on_stack references) on_heap references are managed by GC</td>
      <td>ecma_deref_object (for on_stack references) on_heap references are managed by GC</td>
    </tr>
    <tr>
      <td>Property</td>
      <td>(ownership is strongly connected with corresponding object)</td>
      <td>(ownership is strongly connected with corresponding object)</td>
    </tr>
    <tr>
      <td>Simple value</td>
      <td>no memory management</td>
      <td>no memory management</td>
    </tr>
    <tr>
      <td>ecma_value (including values contained in completion value)</td>
      <td>ecma_copy_value</td>
      <td>ecma_free_value</td>
    </tr>
  </tbody>
</table>

<p>Initially, value is allocated by its owner (i.e with ownership).<br />
Value, passed in argument is passed without ownership.<br />
Value, returned from function is returned with ownership.<br />
Rules for completion value are the same as rules for values, contained in them.</p>

<h2 id="opcode-handler-structure">Opcode handler structure</h2>

<p>Most opcode handlers consists of the following steps:<br />
1. Decode instruction (i.e. extract “idx”-s)<br />
2. Read input values from variables/registers<br />
3. Perform necessary type conversions<br />
4. Perform calls to runtime<br />
5. Save execution result to output variable<br />
6. Increment opcode position counter<br />
7. Return completion value.</p>

<p>Steps 2-5 can produce exceptions.<br />
In this case execution is continued after corresponding FINALIZE mark, and completion value is set to throw exception.</p>

<h2 id="exception-handling">Exception handling</h2>

<p>Operations that could produce exceptions should be performed in one of the following ways:<br />
- wrapped into ECMA_TRY_CATCH block:<br />
  <code>ECMA_TRY_CATCH (value_returned_from_op, op (... ),</code><br />
  <code>ret_value_of_the_whole_routine_handler)</code><code>
  </code>…<code>
  </code>ECMA_FINALIZE(value_returned_from_op);<code>
  </code>return ret_value;<code>
- </code>ret_value = op(…);`<br />
- manual handling (for special cases like interpretation of opfunc_try_block).</p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">
  <div class="wrapper">
      <!--
    <h2 class="footer-heading">JerryScript Engine</h2>
    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>JerryScript Engine</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

    <h3 class="footer-heading">JerryScript Engine</h2>
    <div class="footer-col footer-col-5">
        <p class="text">JerryScript is a very lightweight JavaScript engine with capability to run on microcontrollers with less then 8KB of RAM.
</p>
    </div>
-->
    <div class="footer-copy">
        <p> &copy; Copyright 2015 Samsung Electronics Co., Ltd., Licensed under the  <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License, Version 2.0</a>.</p>
    </div>
  </div>
</footer>


  </body>

</html>
